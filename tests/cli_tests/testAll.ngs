#!/usr/bin/env ngs

# NGS language - https://github.com/ilyash/ngs/

# ---------- Environment sanity checks ----------

assert('BEAME_INTERNAL_AUTH_SERVER_FQDN' in ENV, 'Environment variable BEAME_INTERNAL_AUTH_SERVER_FQDN must be set')

if 'BEAME_DIR' in ENV {
	throw Error("BEAME_DIR environment variable must be unset for tests")
}

HOME = ENV.HOME

BEAME_DIR = HOME / '.beame'
BEAME_BIN = HOME / 'beame-sdk/src/cli/beame.js'
BEAME_DEV_AUTH_FQDN = 'n6ge8i9q4b4b5vb6.h40d7vrwir2oxlnn.v1.d.beameio.net'

if Path(BEAME_DIR) {
	throw Error("Beame directory exists ($BEAME_DIR). Will not run tests.")
}

# ---------- Environment setup ----------

{ ENV['SNI_SERVER_PORT'] = '0' }

# ---------- Tests "framework" ----------

TEST_DATA = 'abcd0123~!@#'
CREDS_FILE = "/tmp/beame-cli-test-creds-${time()}"

entity = null
entity_name = "sdk-test-${time()}"
entity_email = "$entity_name@example.com"
registration = null
exit_code = 0

{ type TestFail(Error) }

F do_test(name:Str, f:Fun) {
	echo("")
	echo("=== TEST: $name ===")
	result = try {
		msg = f()
		"OK: $msg"
	} catch(tf:TestFail) {
		global exit_code = max([exit_code, 1])
		"FAIL: ${tf.message}"
	} catch(e) {
		global exit_code = max([exit_code, 2])
		"FAIL: $e"
	}
	echo("  RESULT: $result")
}

# ---------- Tests library ----------


doc Copies Beame test requests signing credential into store for L0 entity creation
F copy_to_store() {
	$(cp -a "$HOME/$BEAME_DEV_AUTH_FQDN" "$HOME/.beame/v2/$BEAME_DEV_AUTH_FQDN")
	'Copied'
}

doc Creates token needed for signing request for level 0 entity
F create_token() {
	global token = ``$BEAME_BIN token create --fqdn $BEAME_DEV_AUTH_FQDN --data NONE --format json``
	assert(token is Str, "Token expected to be a string")
	token
}

doc Emulate site registration
F register_on_site() {
	global registration = ``curl -s -X POST -H "X-BeameAuthToken: $token" "https://${ENV.BEAME_INTERNAL_AUTH_SERVER_FQDN}/test/sdk/register" -d "email=$entity_email&name=$entity_name"``
	registration is not Hash throws TestFail("Registration must be hash, not '$entity'")
	'authToken' not in registration throws TestFail("Registration has no authToken")
	registration
}

doc Creates an entity
F create_entity() {
	global entity = ``$BEAME_BIN creds getCreds --token ${registration.authToken.encode_json()} --format json``
	entity is not Hash throws TestFail("Entity must be hash, not '$entity'")
	entity.get('parent_fqdn', null) throws TestFail("Entity has parent FQDN: ${entity.parent_fqdn}")
	entity.level !=0 throws TestFail("Entity has non-zero level: ${entity.level}")
	entity.email != entity_email throws TestFail("Entity email mismatch")
	entity.name != entity_name throws TestFail("Entity name mismatch")
	entity
}

# ---------- Tests ----------

F finished_ok(p:Process) {
	guard p.command.argv == [BEAME_BIN]
	p.exit_code == 1
}

do_test("Run without arguments", {
	out = `$BEAME_BIN`
	'beame.js creds list' not in out throws TestFail("Expected text not found")
	"OK"
})
do_test("Copy $BEAME_DEV_AUTH_FQDN into store", copy_to_store)
do_test("Create token for an entity", create_token)
do_test("Emulate site registration", register_on_site)
do_test("Create test entity", create_entity);


c_exit(exit_code)

do_test("Create test entity", F() {
	global entity = ``$BEAME_BIN creds createTestEntity --entityName entityName $ENTITY_NAME --entityEmail $ENTITY_EMAIL --format json``
	entity is not Hash throws TestFail("Entity must be hash, not '$entity'")
	entity.email != ENTITY_EMAIL throws TestFail("Entity email mismatch")
	entity
})


each_idx_val(atoms, F(atom_idx, atom) {
	for(i;EDGE_CLIENTS_PER_ATOM) {
		do_test("Create edge client #$i for atom ${atom.hostname}", F() {
			edge_client = ``$BEAME_BIN creds createEdgeClient --atomFqdn ${atom.hostname} --format json``
			# TODO: checks
			edge_clients.push(edge_client)
			edge_client
		})
	}
})

encrypted_data = null

if atoms {
	do_test("Encrypt data", F() {
		global encrypted_data = `$BEAME_BIN crypto encrypt --data $TEST_DATA --fqdn ${atoms[0].hostname}`
		enc = encrypted_data.decode_json()
		enc is not Hash throws TestFail("Encrypted data must be hash, not $enc")
		%[rsaCipheredKeys data encryptedFor].each(F(k) k not in enc throws TestFail("Key $k is missing in 'encrypt' output"))
		enc.encryptedFor != atoms[0].hostname throws TestFail("encryptedFor mismatch")
		enc
	})
}

if encrypted_data {
	do_test("Decrypt data", F() {
		dec = ``$BEAME_BIN crypto decrypt --data $encrypted_data``
		dec != TEST_DATA throws TestFail("Decrypted data is not the same as the original data")
		"Decryped data was same as the original data"
	})
}

data_signature = null
if atoms {
	do_test("Sign data", F() {
		global data_signature = `$BEAME_BIN crypto sign --data $TEST_DATA --fqdn ${atoms[0].hostname}`
		sig = data_signature.decode_json()
		sig is not Str throws TestFail("Signature is not a string")
		sig
	})
}

if data_signature {
	do_test("Check good signature", F() {
		 chk = ``$BEAME_BIN crypto checkSignature --data $TEST_DATA --fqdn ${atoms[0].hostname} --signature $data_signature``
		 chk !== true throws TestFail("Good signature check did not return true but '$chk'")
		 chk
	})
	do_test("Check good signature for tampered data", F() {
		 chk = ``$BEAME_BIN crypto checkSignature --data ${TEST_DATA+'xyz'} --fqdn ${atoms[0].hostname} --signature $data_signature``
		 chk !== false throws TestFail("Good signature check did not return false for tampered data but '$chk'")
		 chk
	})
}

creds_exported = false
if atoms.len() >= 2 {
	do_test("Export credentials", F() {
		ENV.get('SKIP_EXPORT', false) returns "SKIPPED"
		exp = ``$BEAME_BIN creds exportCredentials --fqdn ${atoms[0].hostname} --targetFqdn ${atoms[1].hostname} --file $CREDS_FILE``
		exp is not Str throws TestFail("exportCredentials did not return a string but '$exp'")
		exp != CREDS_FILE throws TestFail("exportCredentials returned '$exp', not the expected file $CREDS_FILE")
		global creds_exported = true
		exp
	})
}
# XXX
creds_exported = false

if creds_exported {
	F test_creds_exist() {
		ls = ``$BEAME_BIN creds list --fqdn ${atoms[0].hostname} --format json``
		ls is not Arr throws TestFail("Creds list did not return an array")
		ls.len() != 1 throws TestFail("Creds list length is not 1")
		ls[0].hostname != atoms[0].hostname throws TestFail("Creds list returned the wrong item")
		ls
	}
	do_test("[Import credentials] Test credentials exist before deleting them", test_creds_exist)
	do_test("[Import credentials] Deleting exported credentials", F() {
		# TODO: CLI command
		$(rm -rf "$BEAME_DIR/v1/local/${entity.hostname}/${atoms[0].hostname}")
		"deleted"
	})
	do_test("[Import credentials] Test credentials do not exist before importing", F() {
		ls = ``$BEAME_BIN creds list --fqdn ${atoms[0].hostname} --format json``
		ls is not Arr throws TestFail("Creds list did not return an array")
		ls.len() != 0 throws TestFail("Creds list length is not 0")
		ls
	})
	do_test("[Import credentials] Check certificate exists", F() {
		# https://beameio-net-certs-dev.s3.amazonaws.com/h9dgcv7wdlsff7oo.h7zujy4ch0hg8rgd.v1.beameio.net/x509.pem
		url = "https://beameio-net-certs-dev.s3.amazonaws.com/${atoms[0].hostname}/x509.pem"
		$(curl -s $url)
		"URL $url is available"
	})
	do_test("[Import credentials] Import", F() {
		imp = ``$BEAME_BIN creds importCredentials --file $CREDS_FILE``
		imp is not Bool throws TestFail("Import result must be a boolean, not '$imp'")
		not(imp) throws TestFail("Import did not return true")
		imp
	})
	do_test("[Import credentials] Test credentials exist after import", test_creds_exist)
}

if edge_clients {
	do_test('HTTPS servers', F() {

		F bad_output(s:Str) 'hello world' not in s

		servers = edge_clients.map(F(edge_client) {
			echo("  Starting server at https://${edge_client.hostname}/")
			Thread(F() $($BEAME_BIN servers HttpsServerTestStart --edgeClientFqdn ${edge_client.hostname}))
		})
		echo("  Waiting 5 seconds for servers to come up")
		$(sleep 5)
		echo("  Fetching URLs")
		outputs = edge_clients.pmap(F(edge_client) {
			`curl --silent --max-time 10 "https://${edge_client.hostname}/"`
		})
		echo("  Killing servers")
		$(pkill -f HttpsServerTestStart)
		servers.join()
		echo("  Checking outputs")
		outputs.any(is, ProcessFail) throws TestFail("Some curl processes failed: $outputs")
		outputs.any(bad_output) throws TestFail("Some outputs were not OK: $outputs")
		"All ${outputs.len()} outputs were correct"
	})
}

do_test("S3 credentials", F() {
	results = ([entity] + atoms + edge_clients).hostname.map(F(hostname) {
		echo("  Checking $hostname")
		url = "https://beameio-net-certs-dev.s3.amazonaws.com/${atoms[0].hostname}/x509.pem"
		try {
			$(curl -m 5 -s $url)
			true
		} catch(pf:ProcessFail) {
			false
		}
	})
	oks = results.count()
	oks < results.len() throws TestFail("Only $oks out of ${results.len()} certificates are present in S3")
	"All $oks certificates present in S3"
})

if Path(CREDS_FILE) {
	echo("+ Removing temporary credentials file $CREDS_FILE")
	$(rm $CREDS_FILE)
}

# echo("")
# echo("--- info ---")
# echo("ATOMS: $atoms")
# echo("EDGE CLIENTS: $edge_clients")
echo("All tests done. Exit code: $exit_code")
{ exit_code }
